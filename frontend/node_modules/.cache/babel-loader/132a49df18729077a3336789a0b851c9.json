{"ast":null,"code":"/**\n * @module Graph/helper\n * @description\n * Offers a series of methods that isolate logic of Graph component and also from Graph rendering methods.\n */\n\n/**\n * @typedef {Object} Link\n * @property {string} source - the node id of the source in the link.\n * @property {string} target - the node id of the target in the link.\n * @memberof Graph/helper\n */\n\n/**\n * @typedef {Object} Node\n * @property {string} id - the id of the node.\n * @property {string} [color=] - color of the node (optional).\n * @property {string} [fontColor=] - node text label font color (optional).\n * @property {string} [size=] - size of the node (optional).\n * @property {string} [symbolType=] - symbol type of the node (optional).\n * @property {string} [svg=] - custom svg for node (optional).\n * @memberof Graph/helper\n */\nimport { forceX as d3ForceX, forceY as d3ForceY, forceSimulation as d3ForceSimulation, forceManyBody as d3ForceManyBody } from \"d3-force\";\nimport CONST from \"./graph.const\";\nimport DEFAULT_CONFIG from \"./graph.config\";\nimport ERRORS from \"../err\";\nimport { isDeepEqual, isEmptyObject, merge, pick, antiPick, throwErr, throwWarning } from \"../utils\";\nimport { computeNodeDegree } from \"./collapse.helper\";\nconst NODE_PROPS_WHITELIST = [\"id\", \"highlighted\", \"x\", \"y\", \"index\", \"vy\", \"vx\"];\nconst LINK_PROPS_WHITELIST = [\"index\", \"source\", \"target\", \"isHidden\"];\n/**\n * Create d3 forceSimulation to be applied on the graph.<br/>\n * {@link https://github.com/d3/d3-force#forceSimulation|d3-force#forceSimulation}<br/>\n * {@link https://github.com/d3/d3-force#simulation_force|d3-force#simulation_force}<br/>\n * Wtf is a force? {@link https://github.com/d3/d3-force#forces| here}\n * @param  {number} width - the width of the container area of the graph.\n * @param  {number} height - the height of the container area of the graph.\n * @param  {number} gravity - the force strength applied to the graph.\n * @returns {Object} returns the simulation instance to be consumed.\n * @memberof Graph/helper\n */\n\nfunction _createForceSimulation(width, height, gravity) {\n  const frx = d3ForceX(width / 2).strength(CONST.FORCE_X);\n  const fry = d3ForceY(height / 2).strength(CONST.FORCE_Y);\n  const forceStrength = gravity;\n  return d3ForceSimulation().force(\"charge\", d3ForceManyBody().strength(forceStrength)).force(\"x\", frx).force(\"y\", fry);\n}\n/**\n * Receives a matrix of the graph with the links source and target as concrete node instances and it transforms it\n * in a lightweight matrix containing only links with source and target being strings representative of some node id\n * and the respective link value (if non existent will default to 1).\n * @param  {Array.<Link>} graphLinks - an array of all graph links.\n * @param  {Object} config - the graph config.\n * @returns {Object.<string, Object>} an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @memberof Graph/helper\n */\n\n\nfunction _initializeLinks(graphLinks, config) {\n  return graphLinks.reduce((links, l) => {\n    const source = getId(l.source);\n    const target = getId(l.target);\n\n    if (!links[source]) {\n      links[source] = {};\n    }\n\n    if (!links[target]) {\n      links[target] = {};\n    }\n\n    const value = config.collapsible && l.isHidden ? 0 : l.value || 1;\n    links[source][target] = value;\n\n    if (!config.directed) {\n      links[target][source] = value;\n    }\n\n    return links;\n  }, {});\n}\n/**\n * Method that initialize graph nodes provided by rd3g consumer and adds additional default mandatory properties\n * that are optional for the user. Also it generates an index mapping, this maps nodes ids the their index in the array\n * of nodes. This is needed because d3 callbacks such as node click and link click return the index of the node.\n * @param  {Array.<Node>} graphNodes - the array of nodes provided by the rd3g consumer.\n * @returns {Object.<string, Object>} returns the nodes ready to be used within rd3g with additional properties such as x, y\n * and highlighted values.\n * @memberof Graph/helper\n */\n\n\nfunction _initializeNodes(graphNodes) {\n  let nodes = {};\n  const n = graphNodes.length;\n\n  for (let i = 0; i < n; i++) {\n    const node = graphNodes[i];\n    node.highlighted = false;\n\n    if (!Object.prototype.hasOwnProperty.call(node, \"x\")) {\n      node.x = // eslint-disable-next-line no-restricted-globals\n      screen.width / 3 * (Math.random() * (0.8 - -0.8) + 0.8).toFixed(2);\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(node, \"y\")) {\n      node.y = // eslint-disable-next-line no-restricted-globals\n      screen.height / 3 * (Math.random() * (0.5 - -0.5) + 0.5).toFixed(2);\n    }\n\n    nodes[node.id.toString()] = node;\n  }\n\n  return nodes;\n}\n/**\n * Maps an input link (with format `{ source: 'sourceId', target: 'targetId' }`) to a d3Link\n * (with format `{ source: { id: 'sourceId' }, target: { id: 'targetId' } }`). If d3Link with\n * given index exists already that same d3Link is returned.\n * @param {Object} link - input link.\n * @param {number} index - index of the input link.\n * @param {Array.<Object>} d3Links - all d3Links.\n * @param  {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {Object} state - Graph component current state (same format as returned object on this function).\n * @returns {Object} a d3Link.\n * @memberof Graph/helper\n */\n\n\nfunction _mergeDataLinkWithD3Link(link, index, d3Links = [], config, state = {}) {\n  // find the matching link if it exists\n  const tmp = d3Links.find(l => l.source.id === link.source && l.target.id === link.target);\n  const d3Link = tmp && pick(tmp, LINK_PROPS_WHITELIST);\n  const customProps = antiPick(link, [\"source\", \"target\"]);\n\n  if (d3Link) {\n    const toggledDirected = state.config && Object.prototype.hasOwnProperty.call(state.config, \"directed\") && config.directed !== state.config.directed;\n    const refinedD3Link = {\n      index,\n      ...d3Link,\n      ...customProps\n    }; // every time we toggle directed config all links should be visible again\n\n    if (toggledDirected) {\n      return { ...refinedD3Link,\n        isHidden: false\n      };\n    } // every time we disable collapsible (collapsible is false) all links should be visible again\n\n\n    return config.collapsible ? refinedD3Link : { ...refinedD3Link,\n      isHidden: false\n    };\n  }\n\n  const highlighted = false;\n  const source = {\n    id: link.source,\n    highlighted\n  };\n  const target = {\n    id: link.target,\n    highlighted\n  };\n  return {\n    index,\n    source,\n    target,\n    ...customProps\n  };\n}\n/**\n * Tags orphan nodes with a `_orphan` flag.\n * @param {Object.<string, Object>} nodes - nodes mapped by their id.\n * @param {Object.<string, Object>} linksMatrix - an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @returns {Object.<string, Object>} same input nodes structure with tagged orphans nodes where applicable.\n * @memberof Graph/helper\n */\n\n\nfunction _tagOrphanNodes(nodes, linksMatrix) {\n  return Object.keys(nodes).reduce((acc, nodeId) => {\n    const {\n      inDegree,\n      outDegree\n    } = computeNodeDegree(nodeId, linksMatrix);\n    const node = nodes[nodeId];\n    const taggedNode = inDegree === 0 && outDegree === 0 ? { ...node,\n      _orphan: true\n    } : node;\n    acc[nodeId] = taggedNode;\n    return acc;\n  }, {});\n}\n/**\n * Some integrity validations on links and nodes structure. If some validation fails the function will\n * throw an error.\n * @param  {Object} data - Same as {@link #initializeGraphState|data in initializeGraphState}.\n * @throws can throw the following error or warning msg:\n * INSUFFICIENT_DATA - msg if no nodes are provided\n * INVALID_LINKS - if links point to nonexistent nodes\n * INSUFFICIENT_LINKS - if no links are provided\n * @returns {undefined}\n * @memberof Graph/helper\n */\n\n\nfunction _validateGraphData(data) {\n  if (!data.nodes || !data.nodes.length) {\n    throwErr(\"Graph\", ERRORS.INSUFFICIENT_DATA);\n  }\n\n  if (!data.links || !data.links.length) {\n    throwWarning(\"Graph\", ERRORS.INSUFFICIENT_LINKS);\n    data.links = [];\n  }\n\n  const n = data.links.length;\n\n  for (let i = 0; i < n; i++) {\n    const l = data.links[i];\n\n    if (!data.nodes.find(n => n.id === l.source)) {\n      throwErr(\"Graph\", `${ERRORS.INVALID_LINKS} - \"${l.source}\" is not a valid source node id`);\n    }\n\n    if (!data.nodes.find(n => n.id === l.target)) {\n      throwErr(\"Graph\", `${ERRORS.INVALID_LINKS} - \"${l.target}\" is not a valid target node id`);\n    }\n\n    if (l && l.value !== undefined && typeof l.value !== \"number\") {\n      throwErr(\"Graph\", `${ERRORS.INVALID_LINK_VALUE} - found in link with source \"${l.source}\" and target \"${l.target}\"`);\n    }\n  }\n} // list of properties that are of no interest when it comes to nodes and links comparison\n\n\nconst NODE_PROPERTIES_DISCARD_TO_COMPARE = [\"x\", \"y\", \"vx\", \"vy\", \"index\"];\n/**\n * Picks the id.\n * @param {Object} o object to pick from.\n * @returns {Object} new object with id property only.\n * @memberof Graph/helper\n */\n\nfunction _pickId(o) {\n  return pick(o, [\"id\"]);\n}\n/**\n * Picks source and target.\n * @param {Object} o object to pick from.\n * @returns {Object} new object with source and target only.\n * @memberof Graph/helper\n */\n\n\nfunction _pickSourceAndTarget(o) {\n  return pick(o, [\"source\", \"target\"]);\n}\n/**\n * This function checks for graph elements (nodes and links) changes, in two different\n * levels of significance, updated elements (whether some property has changed in some\n * node or link) and new elements (whether some new elements or added/removed from the graph).\n * @param {Object} nextProps - nextProps that graph will receive.\n * @param {Object} currentState - the current state of the graph.\n * @returns {Object.<string, boolean>} returns object containing update check flags:\n * - newGraphElements - flag that indicates whether new graph elements were added.\n * - graphElementsUpdated - flag that indicates whether some graph elements have\n * updated (some property that is not in NODE_PROPERTIES_DISCARD_TO_COMPARE was added to\n * some node or link or was updated).\n * @memberof Graph/helper\n */\n\n\nfunction checkForGraphElementsChanges(nextProps, currentState) {\n  const nextNodes = nextProps.data.nodes.map(n => antiPick(n, NODE_PROPERTIES_DISCARD_TO_COMPARE));\n  const nextLinks = nextProps.data.links;\n  const stateD3Nodes = currentState.d3Nodes.map(n => antiPick(n, NODE_PROPERTIES_DISCARD_TO_COMPARE));\n  const stateD3Links = currentState.d3Links.map(l => ({\n    source: getId(l.source),\n    target: getId(l.target)\n  }));\n  const graphElementsUpdated = !(isDeepEqual(nextNodes, stateD3Nodes) && isDeepEqual(nextLinks, stateD3Links));\n  const newGraphElements = nextNodes.length !== stateD3Nodes.length || nextLinks.length !== stateD3Links.length || !isDeepEqual(nextNodes.map(_pickId), stateD3Nodes.map(_pickId)) || !isDeepEqual(nextLinks.map(_pickSourceAndTarget), stateD3Links.map(_pickSourceAndTarget));\n  return {\n    graphElementsUpdated,\n    newGraphElements\n  };\n}\n/**\n * Logic to check for changes in graph config.\n * @param {Object} nextProps - nextProps that graph will receive.\n * @param {Object} currentState - the current state of the graph.\n * @returns {Object.<string, boolean>} returns object containing update check flags:\n * - configUpdated - global flag that indicates if any property was updated.\n * - d3ConfigUpdated - specific flag that indicates changes in d3 configurations.\n * @memberof Graph/helper\n */\n\n\nfunction checkForGraphConfigChanges(nextProps, currentState) {\n  const newConfig = nextProps.config || {};\n  const configUpdated = newConfig && !isEmptyObject(newConfig) && !isDeepEqual(newConfig, currentState.config);\n  const d3ConfigUpdated = newConfig && newConfig.d3 && !isDeepEqual(newConfig.d3, currentState.config.d3);\n  return {\n    configUpdated,\n    d3ConfigUpdated\n  };\n}\n/**\n * Returns the transformation to apply in order to center the graph on the\n * selected node.\n * @param {Object} d3Node - node to focus the graph view on.\n * @param {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @returns {string|undefined} transform rule to apply.\n * @memberof Graph/helper\n */\n\n\nfunction getCenterAndZoomTransformation(d3Node, config) {\n  if (!d3Node) {\n    return;\n  }\n\n  const {\n    width,\n    height,\n    focusZoom\n  } = config;\n  return `\n        translate(${width / 2}, ${height / 2})\n        scale(${focusZoom})\n        translate(${-d3Node.x}, ${-d3Node.y})\n    `;\n}\n/**\n * This function extracts an id from a link.\n * **Why this function?**\n * According to [d3-force](https://github.com/d3/d3-force#link_links)\n * d3 links might be initialized with \"source\" and \"target\"\n * properties as numbers or strings, but after initialization they\n * are converted to an object. This small utility functions ensures\n * that weather in initialization or further into the lifetime of the graph\n * we always get the id.\n * @param {Object|string|number} sot source or target\n * of the link to extract id.\n * we want to extract an id.\n * @returns {string|number} the id of the link.\n * @memberof Graph/helper\n */\n\n\nfunction getId(sot) {\n  return sot.id !== undefined && sot.id !== null ? sot.id : sot;\n}\n/**\n * Encapsulates common procedures to initialize graph.\n * @param {Object} props - Graph component props, object that holds data, id and config.\n * @param {Object} props.data - Data object holds links (array of **Link**) and nodes (array of **Node**).\n * @param {string} props.id - the graph id.\n * @param {Object} props.config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {Object} state - Graph component current state (same format as returned object on this function).\n * @returns {Object} a fully (re)initialized graph state object.\n * @memberof Graph/helper\n */\n\n\nfunction initializeGraphState({\n  data,\n  id,\n  config,\n  algoData\n}, state) {\n  _validateGraphData(data);\n\n  let graph;\n\n  if (state && state.nodes) {\n    graph = {\n      nodes: data.nodes.map(n => state.nodes[n.id] ? { ...n,\n        ...pick(state.nodes[n.id], NODE_PROPS_WHITELIST)\n      } : { ...n\n      }),\n      links: data.links.map((l, index) => _mergeDataLinkWithD3Link(l, index, state && state.d3Links, config, state))\n    };\n  } else {\n    graph = {\n      nodes: data.nodes.map(n => ({ ...n\n      })),\n      links: data.links.map(l => ({ ...l\n      }))\n    };\n  }\n\n  let newConfig = { ...merge(DEFAULT_CONFIG, config || {})\n  },\n      links = _initializeLinks(graph.links, newConfig),\n      // matrix of graph connections\n  nodes = _tagOrphanNodes(_initializeNodes(graph.nodes), links);\n\n  const {\n    nodes: d3Nodes,\n    links: d3Links\n  } = graph;\n  const formatedId = id.replace(/ /g, \"_\");\n\n  const simulation = _createForceSimulation(newConfig.width, newConfig.height, newConfig.d3 && newConfig.d3.gravity);\n\n  const {\n    minZoom,\n    maxZoom,\n    focusZoom\n  } = newConfig;\n\n  if (focusZoom > maxZoom) {\n    newConfig.focusZoom = maxZoom;\n  } else if (focusZoom < minZoom) {\n    newConfig.focusZoom = minZoom;\n  }\n\n  return {\n    id: formatedId,\n    config: newConfig,\n    links,\n    d3Links,\n    nodes,\n    d3Nodes,\n    highlightedNode: \"\",\n    simulation,\n    newGraphElements: false,\n    configUpdated: false,\n    transform: 1,\n    draggedNode: null\n  };\n}\n/**\n * This function updates the highlighted value for a given node and also updates highlight props.\n * @param {Object.<string, Object>} nodes - an object containing all nodes mapped by their id.\n * @param {Object.<string, Object>} links - an object containing a matrix of connections of the graph.\n * @param {Object} config - an object containing rd3g consumer defined configurations {@link #config config} for the graph.\n * @param {string} id - identifier of node to update.\n * @param {string} value - new highlight value for given node.\n * @returns {Object} returns an object containing the updated nodes\n * and the id of the highlighted node.\n * @memberof Graph/helper\n */\n\n\nfunction updateNodeHighlightedValue(nodes, links, config, id, value = false) {\n  const highlightedNode = value ? id : \"\";\n  const node = { ...nodes[id],\n    highlighted: value\n  };\n  let updatedNodes = { ...nodes,\n    [id]: node\n  }; // when highlightDegree is 0 we want only to highlight selected node\n\n  if (links[id] && config.highlightDegree !== 0) {\n    updatedNodes = Object.keys(links[id]).reduce((acc, linkId) => {\n      const updatedNode = { ...updatedNodes[linkId],\n        highlighted: value\n      };\n      acc[linkId] = updatedNode;\n      return acc;\n    }, updatedNodes);\n  }\n\n  return {\n    nodes: updatedNodes,\n    highlightedNode\n  };\n}\n\nexport { checkForGraphConfigChanges, checkForGraphElementsChanges, getCenterAndZoomTransformation, getId, initializeGraphState, updateNodeHighlightedValue };","map":{"version":3,"sources":["/Users/baljeetsingh/Desktop/software/s2020-djma/algo_interact/frontend/src/components/Visualizer/Graph/Graph/graph/graph.helper.js"],"names":["forceX","d3ForceX","forceY","d3ForceY","forceSimulation","d3ForceSimulation","forceManyBody","d3ForceManyBody","CONST","DEFAULT_CONFIG","ERRORS","isDeepEqual","isEmptyObject","merge","pick","antiPick","throwErr","throwWarning","computeNodeDegree","NODE_PROPS_WHITELIST","LINK_PROPS_WHITELIST","_createForceSimulation","width","height","gravity","frx","strength","FORCE_X","fry","FORCE_Y","forceStrength","force","_initializeLinks","graphLinks","config","reduce","links","l","source","getId","target","value","collapsible","isHidden","directed","_initializeNodes","graphNodes","nodes","n","length","i","node","highlighted","Object","prototype","hasOwnProperty","call","x","screen","Math","random","toFixed","y","id","toString","_mergeDataLinkWithD3Link","link","index","d3Links","state","tmp","find","d3Link","customProps","toggledDirected","refinedD3Link","_tagOrphanNodes","linksMatrix","keys","acc","nodeId","inDegree","outDegree","taggedNode","_orphan","_validateGraphData","data","INSUFFICIENT_DATA","INSUFFICIENT_LINKS","INVALID_LINKS","undefined","INVALID_LINK_VALUE","NODE_PROPERTIES_DISCARD_TO_COMPARE","_pickId","o","_pickSourceAndTarget","checkForGraphElementsChanges","nextProps","currentState","nextNodes","map","nextLinks","stateD3Nodes","d3Nodes","stateD3Links","graphElementsUpdated","newGraphElements","checkForGraphConfigChanges","newConfig","configUpdated","d3ConfigUpdated","d3","getCenterAndZoomTransformation","d3Node","focusZoom","sot","initializeGraphState","algoData","graph","formatedId","replace","simulation","minZoom","maxZoom","highlightedNode","transform","draggedNode","updateNodeHighlightedValue","updatedNodes","highlightDegree","linkId","updatedNode"],"mappings":"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","sourcesContent":["/**\n * @module Graph/helper\n * @description\n * Offers a series of methods that isolate logic of Graph component and also from Graph rendering methods.\n */\n/**\n * @typedef {Object} Link\n * @property {string} source - the node id of the source in the link.\n * @property {string} target - the node id of the target in the link.\n * @memberof Graph/helper\n */\n/**\n * @typedef {Object} Node\n * @property {string} id - the id of the node.\n * @property {string} [color=] - color of the node (optional).\n * @property {string} [fontColor=] - node text label font color (optional).\n * @property {string} [size=] - size of the node (optional).\n * @property {string} [symbolType=] - symbol type of the node (optional).\n * @property {string} [svg=] - custom svg for node (optional).\n * @memberof Graph/helper\n */\nimport {\n  forceX as d3ForceX,\n  forceY as d3ForceY,\n  forceSimulation as d3ForceSimulation,\n  forceManyBody as d3ForceManyBody,\n} from \"d3-force\";\n\nimport CONST from \"./graph.const\";\nimport DEFAULT_CONFIG from \"./graph.config\";\nimport ERRORS from \"../err\";\n\nimport {\n  isDeepEqual,\n  isEmptyObject,\n  merge,\n  pick,\n  antiPick,\n  throwErr,\n  throwWarning,\n} from \"../utils\";\nimport { computeNodeDegree } from \"./collapse.helper\";\n\nconst NODE_PROPS_WHITELIST = [\n  \"id\",\n  \"highlighted\",\n  \"x\",\n  \"y\",\n  \"index\",\n  \"vy\",\n  \"vx\",\n];\nconst LINK_PROPS_WHITELIST = [\"index\", \"source\", \"target\", \"isHidden\"];\n\n/**\n * Create d3 forceSimulation to be applied on the graph.<br/>\n * {@link https://github.com/d3/d3-force#forceSimulation|d3-force#forceSimulation}<br/>\n * {@link https://github.com/d3/d3-force#simulation_force|d3-force#simulation_force}<br/>\n * Wtf is a force? {@link https://github.com/d3/d3-force#forces| here}\n * @param  {number} width - the width of the container area of the graph.\n * @param  {number} height - the height of the container area of the graph.\n * @param  {number} gravity - the force strength applied to the graph.\n * @returns {Object} returns the simulation instance to be consumed.\n * @memberof Graph/helper\n */\nfunction _createForceSimulation(width, height, gravity) {\n  const frx = d3ForceX(width / 2).strength(CONST.FORCE_X);\n  const fry = d3ForceY(height / 2).strength(CONST.FORCE_Y);\n  const forceStrength = gravity;\n\n  return d3ForceSimulation()\n    .force(\"charge\", d3ForceManyBody().strength(forceStrength))\n    .force(\"x\", frx)\n    .force(\"y\", fry);\n}\n\n/**\n * Receives a matrix of the graph with the links source and target as concrete node instances and it transforms it\n * in a lightweight matrix containing only links with source and target being strings representative of some node id\n * and the respective link value (if non existent will default to 1).\n * @param  {Array.<Link>} graphLinks - an array of all graph links.\n * @param  {Object} config - the graph config.\n * @returns {Object.<string, Object>} an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @memberof Graph/helper\n */\nfunction _initializeLinks(graphLinks, config) {\n  return graphLinks.reduce((links, l) => {\n    const source = getId(l.source);\n    const target = getId(l.target);\n\n    if (!links[source]) {\n      links[source] = {};\n    }\n\n    if (!links[target]) {\n      links[target] = {};\n    }\n\n    const value = config.collapsible && l.isHidden ? 0 : l.value || 1;\n\n    links[source][target] = value;\n\n    if (!config.directed) {\n      links[target][source] = value;\n    }\n\n    return links;\n  }, {});\n}\n\n/**\n * Method that initialize graph nodes provided by rd3g consumer and adds additional default mandatory properties\n * that are optional for the user. Also it generates an index mapping, this maps nodes ids the their index in the array\n * of nodes. This is needed because d3 callbacks such as node click and link click return the index of the node.\n * @param  {Array.<Node>} graphNodes - the array of nodes provided by the rd3g consumer.\n * @returns {Object.<string, Object>} returns the nodes ready to be used within rd3g with additional properties such as x, y\n * and highlighted values.\n * @memberof Graph/helper\n */\nfunction _initializeNodes(graphNodes) {\n  let nodes = {};\n  const n = graphNodes.length;\n\n  for (let i = 0; i < n; i++) {\n    const node = graphNodes[i];\n\n    node.highlighted = false;\n    if (!Object.prototype.hasOwnProperty.call(node, \"x\")) {\n      node.x =\n        // eslint-disable-next-line no-restricted-globals\n        (screen.width / 3) * (Math.random() * (0.8 - -0.8) + 0.8).toFixed(2);\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(node, \"y\")) {\n      node.y =\n        // eslint-disable-next-line no-restricted-globals\n        (screen.height / 3) * (Math.random() * (0.5 - -0.5) + 0.5).toFixed(2);\n    }\n\n    nodes[node.id.toString()] = node;\n  }\n\n  return nodes;\n}\n\n/**\n * Maps an input link (with format `{ source: 'sourceId', target: 'targetId' }`) to a d3Link\n * (with format `{ source: { id: 'sourceId' }, target: { id: 'targetId' } }`). If d3Link with\n * given index exists already that same d3Link is returned.\n * @param {Object} link - input link.\n * @param {number} index - index of the input link.\n * @param {Array.<Object>} d3Links - all d3Links.\n * @param  {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {Object} state - Graph component current state (same format as returned object on this function).\n * @returns {Object} a d3Link.\n * @memberof Graph/helper\n */\nfunction _mergeDataLinkWithD3Link(\n  link,\n  index,\n  d3Links = [],\n  config,\n  state = {}\n) {\n  // find the matching link if it exists\n  const tmp = d3Links.find(\n    (l) => l.source.id === link.source && l.target.id === link.target\n  );\n  const d3Link = tmp && pick(tmp, LINK_PROPS_WHITELIST);\n  const customProps = antiPick(link, [\"source\", \"target\"]);\n\n  if (d3Link) {\n    const toggledDirected =\n      state.config &&\n      Object.prototype.hasOwnProperty.call(state.config, \"directed\") &&\n      config.directed !== state.config.directed;\n    const refinedD3Link = {\n      index,\n      ...d3Link,\n      ...customProps,\n    };\n\n    // every time we toggle directed config all links should be visible again\n    if (toggledDirected) {\n      return { ...refinedD3Link, isHidden: false };\n    }\n\n    // every time we disable collapsible (collapsible is false) all links should be visible again\n    return config.collapsible\n      ? refinedD3Link\n      : { ...refinedD3Link, isHidden: false };\n  }\n\n  const highlighted = false;\n  const source = {\n    id: link.source,\n    highlighted,\n  };\n  const target = {\n    id: link.target,\n    highlighted,\n  };\n\n  return {\n    index,\n    source,\n    target,\n    ...customProps,\n  };\n}\n\n/**\n * Tags orphan nodes with a `_orphan` flag.\n * @param {Object.<string, Object>} nodes - nodes mapped by their id.\n * @param {Object.<string, Object>} linksMatrix - an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @returns {Object.<string, Object>} same input nodes structure with tagged orphans nodes where applicable.\n * @memberof Graph/helper\n */\nfunction _tagOrphanNodes(nodes, linksMatrix) {\n  return Object.keys(nodes).reduce((acc, nodeId) => {\n    const { inDegree, outDegree } = computeNodeDegree(nodeId, linksMatrix);\n    const node = nodes[nodeId];\n    const taggedNode =\n      inDegree === 0 && outDegree === 0 ? { ...node, _orphan: true } : node;\n\n    acc[nodeId] = taggedNode;\n\n    return acc;\n  }, {});\n}\n\n/**\n * Some integrity validations on links and nodes structure. If some validation fails the function will\n * throw an error.\n * @param  {Object} data - Same as {@link #initializeGraphState|data in initializeGraphState}.\n * @throws can throw the following error or warning msg:\n * INSUFFICIENT_DATA - msg if no nodes are provided\n * INVALID_LINKS - if links point to nonexistent nodes\n * INSUFFICIENT_LINKS - if no links are provided\n * @returns {undefined}\n * @memberof Graph/helper\n */\nfunction _validateGraphData(data) {\n  if (!data.nodes || !data.nodes.length) {\n    throwErr(\"Graph\", ERRORS.INSUFFICIENT_DATA);\n  }\n\n  if (!data.links || !data.links.length) {\n    throwWarning(\"Graph\", ERRORS.INSUFFICIENT_LINKS);\n    data.links = [];\n  }\n\n  const n = data.links.length;\n\n  for (let i = 0; i < n; i++) {\n    const l = data.links[i];\n\n    if (!data.nodes.find((n) => n.id === l.source)) {\n      throwErr(\n        \"Graph\",\n        `${ERRORS.INVALID_LINKS} - \"${l.source}\" is not a valid source node id`\n      );\n    }\n\n    if (!data.nodes.find((n) => n.id === l.target)) {\n      throwErr(\n        \"Graph\",\n        `${ERRORS.INVALID_LINKS} - \"${l.target}\" is not a valid target node id`\n      );\n    }\n\n    if (l && l.value !== undefined && typeof l.value !== \"number\") {\n      throwErr(\n        \"Graph\",\n        `${ERRORS.INVALID_LINK_VALUE} - found in link with source \"${l.source}\" and target \"${l.target}\"`\n      );\n    }\n  }\n}\n\n// list of properties that are of no interest when it comes to nodes and links comparison\nconst NODE_PROPERTIES_DISCARD_TO_COMPARE = [\"x\", \"y\", \"vx\", \"vy\", \"index\"];\n\n/**\n * Picks the id.\n * @param {Object} o object to pick from.\n * @returns {Object} new object with id property only.\n * @memberof Graph/helper\n */\nfunction _pickId(o) {\n  return pick(o, [\"id\"]);\n}\n\n/**\n * Picks source and target.\n * @param {Object} o object to pick from.\n * @returns {Object} new object with source and target only.\n * @memberof Graph/helper\n */\nfunction _pickSourceAndTarget(o) {\n  return pick(o, [\"source\", \"target\"]);\n}\n\n/**\n * This function checks for graph elements (nodes and links) changes, in two different\n * levels of significance, updated elements (whether some property has changed in some\n * node or link) and new elements (whether some new elements or added/removed from the graph).\n * @param {Object} nextProps - nextProps that graph will receive.\n * @param {Object} currentState - the current state of the graph.\n * @returns {Object.<string, boolean>} returns object containing update check flags:\n * - newGraphElements - flag that indicates whether new graph elements were added.\n * - graphElementsUpdated - flag that indicates whether some graph elements have\n * updated (some property that is not in NODE_PROPERTIES_DISCARD_TO_COMPARE was added to\n * some node or link or was updated).\n * @memberof Graph/helper\n */\n\nfunction checkForGraphElementsChanges(nextProps, currentState) {\n  const nextNodes = nextProps.data.nodes.map((n) =>\n    antiPick(n, NODE_PROPERTIES_DISCARD_TO_COMPARE)\n  );\n  const nextLinks = nextProps.data.links;\n  const stateD3Nodes = currentState.d3Nodes.map((n) =>\n    antiPick(n, NODE_PROPERTIES_DISCARD_TO_COMPARE)\n  );\n  const stateD3Links = currentState.d3Links.map((l) => ({\n    source: getId(l.source),\n    target: getId(l.target),\n  }));\n  const graphElementsUpdated = !(\n    isDeepEqual(nextNodes, stateD3Nodes) && isDeepEqual(nextLinks, stateD3Links)\n  );\n  const newGraphElements =\n    nextNodes.length !== stateD3Nodes.length ||\n    nextLinks.length !== stateD3Links.length ||\n    !isDeepEqual(nextNodes.map(_pickId), stateD3Nodes.map(_pickId)) ||\n    !isDeepEqual(\n      nextLinks.map(_pickSourceAndTarget),\n      stateD3Links.map(_pickSourceAndTarget)\n    );\n\n  return { graphElementsUpdated, newGraphElements };\n}\n\n/**\n * Logic to check for changes in graph config.\n * @param {Object} nextProps - nextProps that graph will receive.\n * @param {Object} currentState - the current state of the graph.\n * @returns {Object.<string, boolean>} returns object containing update check flags:\n * - configUpdated - global flag that indicates if any property was updated.\n * - d3ConfigUpdated - specific flag that indicates changes in d3 configurations.\n * @memberof Graph/helper\n */\nfunction checkForGraphConfigChanges(nextProps, currentState) {\n  const newConfig = nextProps.config || {};\n  const configUpdated =\n    newConfig &&\n    !isEmptyObject(newConfig) &&\n    !isDeepEqual(newConfig, currentState.config);\n  const d3ConfigUpdated =\n    newConfig &&\n    newConfig.d3 &&\n    !isDeepEqual(newConfig.d3, currentState.config.d3);\n\n  return { configUpdated, d3ConfigUpdated };\n}\n\n/**\n * Returns the transformation to apply in order to center the graph on the\n * selected node.\n * @param {Object} d3Node - node to focus the graph view on.\n * @param {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @returns {string|undefined} transform rule to apply.\n * @memberof Graph/helper\n */\nfunction getCenterAndZoomTransformation(d3Node, config) {\n  if (!d3Node) {\n    return;\n  }\n\n  const { width, height, focusZoom } = config;\n\n  return `\n        translate(${width / 2}, ${height / 2})\n        scale(${focusZoom})\n        translate(${-d3Node.x}, ${-d3Node.y})\n    `;\n}\n\n/**\n * This function extracts an id from a link.\n * **Why this function?**\n * According to [d3-force](https://github.com/d3/d3-force#link_links)\n * d3 links might be initialized with \"source\" and \"target\"\n * properties as numbers or strings, but after initialization they\n * are converted to an object. This small utility functions ensures\n * that weather in initialization or further into the lifetime of the graph\n * we always get the id.\n * @param {Object|string|number} sot source or target\n * of the link to extract id.\n * we want to extract an id.\n * @returns {string|number} the id of the link.\n * @memberof Graph/helper\n */\nfunction getId(sot) {\n  return sot.id !== undefined && sot.id !== null ? sot.id : sot;\n}\n\n/**\n * Encapsulates common procedures to initialize graph.\n * @param {Object} props - Graph component props, object that holds data, id and config.\n * @param {Object} props.data - Data object holds links (array of **Link**) and nodes (array of **Node**).\n * @param {string} props.id - the graph id.\n * @param {Object} props.config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {Object} state - Graph component current state (same format as returned object on this function).\n * @returns {Object} a fully (re)initialized graph state object.\n * @memberof Graph/helper\n */\nfunction initializeGraphState({ data, id, config, algoData }, state) {\n  _validateGraphData(data);\n\n  let graph;\n\n  if (state && state.nodes) {\n    graph = {\n      nodes: data.nodes.map((n) =>\n        state.nodes[n.id]\n          ? { ...n, ...pick(state.nodes[n.id], NODE_PROPS_WHITELIST) }\n          : { ...n }\n      ),\n      links: data.links.map((l, index) =>\n        _mergeDataLinkWithD3Link(\n          l,\n          index,\n          state && state.d3Links,\n          config,\n          state\n        )\n      ),\n    };\n  } else {\n    graph = {\n      nodes: data.nodes.map((n) => ({ ...n })),\n      links: data.links.map((l) => ({ ...l })),\n    };\n  }\n\n  let newConfig = { ...merge(DEFAULT_CONFIG, config || {}) },\n    links = _initializeLinks(graph.links, newConfig), // matrix of graph connections\n    nodes = _tagOrphanNodes(_initializeNodes(graph.nodes), links);\n  const { nodes: d3Nodes, links: d3Links } = graph;\n  const formatedId = id.replace(/ /g, \"_\");\n  const simulation = _createForceSimulation(\n    newConfig.width,\n    newConfig.height,\n    newConfig.d3 && newConfig.d3.gravity\n  );\n  const { minZoom, maxZoom, focusZoom } = newConfig;\n\n  if (focusZoom > maxZoom) {\n    newConfig.focusZoom = maxZoom;\n  } else if (focusZoom < minZoom) {\n    newConfig.focusZoom = minZoom;\n  }\n\n  return {\n    id: formatedId,\n    config: newConfig,\n    links,\n    d3Links,\n    nodes,\n    d3Nodes,\n    highlightedNode: \"\",\n    simulation,\n    newGraphElements: false,\n    configUpdated: false,\n    transform: 1,\n    draggedNode: null,\n  };\n}\n\n/**\n * This function updates the highlighted value for a given node and also updates highlight props.\n * @param {Object.<string, Object>} nodes - an object containing all nodes mapped by their id.\n * @param {Object.<string, Object>} links - an object containing a matrix of connections of the graph.\n * @param {Object} config - an object containing rd3g consumer defined configurations {@link #config config} for the graph.\n * @param {string} id - identifier of node to update.\n * @param {string} value - new highlight value for given node.\n * @returns {Object} returns an object containing the updated nodes\n * and the id of the highlighted node.\n * @memberof Graph/helper\n */\nfunction updateNodeHighlightedValue(nodes, links, config, id, value = false) {\n  const highlightedNode = value ? id : \"\";\n  const node = { ...nodes[id], highlighted: value };\n\n  let updatedNodes = { ...nodes, [id]: node };\n\n  // when highlightDegree is 0 we want only to highlight selected node\n  if (links[id] && config.highlightDegree !== 0) {\n    updatedNodes = Object.keys(links[id]).reduce((acc, linkId) => {\n      const updatedNode = { ...updatedNodes[linkId], highlighted: value };\n\n      acc[linkId] = updatedNode;\n\n      return acc;\n    }, updatedNodes);\n  }\n\n  return {\n    nodes: updatedNodes,\n    highlightedNode,\n  };\n}\n\nexport {\n  checkForGraphConfigChanges,\n  checkForGraphElementsChanges,\n  getCenterAndZoomTransformation,\n  getId,\n  initializeGraphState,\n  updateNodeHighlightedValue,\n};\n"]},"metadata":{},"sourceType":"module"}