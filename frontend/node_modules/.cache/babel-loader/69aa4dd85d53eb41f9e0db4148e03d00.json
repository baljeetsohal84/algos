{"ast":null,"code":"/**\n * @module Graph/helper\n * @description\n * Offers a series of methods that isolate logic of Graph component and also from Graph rendering methods.\n */\n\n/**\n * @typedef {Object} Link\n * @property {string} source - the node id of the source in the link.\n * @property {string} target - the node id of the target in the link.\n * @memberof Graph/helper\n */\n\n/**\n * @typedef {Object} Node\n * @property {string} id - the id of the node.\n * @property {string} [color=] - color of the node (optional).\n * @property {string} [fontColor=] - node text label font color (optional).\n * @property {string} [size=] - size of the node (optional).\n * @property {string} [symbolType=] - symbol type of the node (optional).\n * @property {string} [svg=] - custom svg for node (optional).\n * @memberof Graph/helper\n */\nimport { forceX as d3ForceX, forceY as d3ForceY, forceSimulation as d3ForceSimulation, forceManyBody as d3ForceManyBody } from \"d3-force\";\nimport CONST from \"./graph.const\";\nimport DEFAULT_CONFIG from \"./graph.config\";\nimport ERRORS from \"../err\";\nimport { isDeepEqual, isEmptyObject, merge, pick, antiPick, throwErr, throwWarning } from \"../utils\";\nimport { computeNodeDegree } from \"./collapse.helper\";\nconst NODE_PROPS_WHITELIST = [\"id\", \"highlighted\", \"x\", \"y\", \"index\", \"vy\", \"vx\"];\nconst LINK_PROPS_WHITELIST = [\"index\", \"source\", \"target\", \"isHidden\"];\n/**\n * Create d3 forceSimulation to be applied on the graph.<br/>\n * {@link https://github.com/d3/d3-force#forceSimulation|d3-force#forceSimulation}<br/>\n * {@link https://github.com/d3/d3-force#simulation_force|d3-force#simulation_force}<br/>\n * Wtf is a force? {@link https://github.com/d3/d3-force#forces| here}\n * @param  {number} width - the width of the container area of the graph.\n * @param  {number} height - the height of the container area of the graph.\n * @param  {number} gravity - the force strength applied to the graph.\n * @returns {Object} returns the simulation instance to be consumed.\n * @memberof Graph/helper\n */\n\nfunction _createForceSimulation(width, height, gravity) {\n  const frx = d3ForceX(width / 2).strength(CONST.FORCE_X);\n  const fry = d3ForceY(height / 2).strength(CONST.FORCE_Y);\n  const forceStrength = gravity;\n  return d3ForceSimulation().force(\"charge\", d3ForceManyBody().strength(forceStrength)).force(\"x\", frx).force(\"y\", fry);\n}\n/**\n * Receives a matrix of the graph with the links source and target as concrete node instances and it transforms it\n * in a lightweight matrix containing only links with source and target being strings representative of some node id\n * and the respective link value (if non existent will default to 1).\n * @param  {Array.<Link>} graphLinks - an array of all graph links.\n * @param  {Object} config - the graph config.\n * @returns {Object.<string, Object>} an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @memberof Graph/helper\n */\n\n\nfunction _initializeLinks(graphLinks, config) {\n  return graphLinks.reduce((links, l) => {\n    const source = getId(l.source);\n    const target = getId(l.target);\n\n    if (!links[source]) {\n      links[source] = {};\n    }\n\n    if (!links[target]) {\n      links[target] = {};\n    }\n\n    const value = config.collapsible && l.isHidden ? 0 : l.value || 1;\n    links[source][target] = value;\n\n    if (!config.directed) {\n      links[target][source] = value;\n    }\n\n    return links;\n  }, {});\n}\n/**\n * Method that initialize graph nodes provided by rd3g consumer and adds additional default mandatory properties\n * that are optional for the user. Also it generates an index mapping, this maps nodes ids the their index in the array\n * of nodes. This is needed because d3 callbacks such as node click and link click return the index of the node.\n * @param  {Array.<Node>} graphNodes - the array of nodes provided by the rd3g consumer.\n * @returns {Object.<string, Object>} returns the nodes ready to be used within rd3g with additional properties such as x, y\n * and highlighted values.\n * @memberof Graph/helper\n */\n\n\nfunction _initializeNodes(graphNodes) {\n  let nodes = {};\n  const n = graphNodes.length;\n\n  for (let i = 0; i < n; i++) {\n    const node = graphNodes[i];\n    node.highlighted = false;\n\n    if (!Object.prototype.hasOwnProperty.call(node, \"x\")) {\n      node.x = 0;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(node, \"y\")) {\n      node.y = 0;\n    }\n\n    nodes[node.id.toString()] = node;\n  }\n\n  return nodes;\n}\n/**\n * Maps an input link (with format `{ source: 'sourceId', target: 'targetId' }`) to a d3Link\n * (with format `{ source: { id: 'sourceId' }, target: { id: 'targetId' } }`). If d3Link with\n * given index exists already that same d3Link is returned.\n * @param {Object} link - input link.\n * @param {number} index - index of the input link.\n * @param {Array.<Object>} d3Links - all d3Links.\n * @param  {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {Object} state - Graph component current state (same format as returned object on this function).\n * @returns {Object} a d3Link.\n * @memberof Graph/helper\n */\n\n\nfunction _mergeDataLinkWithD3Link(link, index, d3Links = [], config, state = {}) {\n  // find the matching link if it exists\n  const tmp = d3Links.find(l => l.source.id === link.source && l.target.id === link.target);\n  const d3Link = tmp && pick(tmp, LINK_PROPS_WHITELIST);\n  const customProps = antiPick(link, [\"source\", \"target\"]);\n\n  if (d3Link) {\n    const toggledDirected = state.config && Object.prototype.hasOwnProperty.call(state.config, \"directed\") && config.directed !== state.config.directed;\n    const refinedD3Link = {\n      index,\n      ...d3Link,\n      ...customProps\n    }; // every time we toggle directed config all links should be visible again\n\n    if (toggledDirected) {\n      return { ...refinedD3Link,\n        isHidden: false\n      };\n    } // every time we disable collapsible (collapsible is false) all links should be visible again\n\n\n    return config.collapsible ? refinedD3Link : { ...refinedD3Link,\n      isHidden: false\n    };\n  }\n\n  const highlighted = false;\n  const source = {\n    id: link.source,\n    highlighted\n  };\n  const target = {\n    id: link.target,\n    highlighted\n  };\n  return {\n    index,\n    source,\n    target,\n    ...customProps\n  };\n}\n/**\n * Tags orphan nodes with a `_orphan` flag.\n * @param {Object.<string, Object>} nodes - nodes mapped by their id.\n * @param {Object.<string, Object>} linksMatrix - an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @returns {Object.<string, Object>} same input nodes structure with tagged orphans nodes where applicable.\n * @memberof Graph/helper\n */\n\n\nfunction _tagOrphanNodes(nodes, linksMatrix) {\n  return Object.keys(nodes).reduce((acc, nodeId) => {\n    const {\n      inDegree,\n      outDegree\n    } = computeNodeDegree(nodeId, linksMatrix);\n    const node = nodes[nodeId];\n    const taggedNode = inDegree === 0 && outDegree === 0 ? { ...node,\n      _orphan: true\n    } : node;\n    acc[nodeId] = taggedNode;\n    return acc;\n  }, {});\n}\n/**\n * Some integrity validations on links and nodes structure. If some validation fails the function will\n * throw an error.\n * @param  {Object} data - Same as {@link #initializeGraphState|data in initializeGraphState}.\n * @throws can throw the following error or warning msg:\n * INSUFFICIENT_DATA - msg if no nodes are provided\n * INVALID_LINKS - if links point to nonexistent nodes\n * INSUFFICIENT_LINKS - if no links are provided\n * @returns {undefined}\n * @memberof Graph/helper\n */\n\n\nfunction _validateGraphData(data) {\n  if (!data.nodes || !data.nodes.length) {\n    throwErr(\"Graph\", ERRORS.INSUFFICIENT_DATA);\n  }\n\n  if (!data.links || !data.links.length) {\n    throwWarning(\"Graph\", ERRORS.INSUFFICIENT_LINKS);\n    data.links = [];\n  }\n\n  const n = data.links.length;\n\n  for (let i = 0; i < n; i++) {\n    const l = data.links[i];\n\n    if (!data.nodes.find(n => n.id === l.source)) {\n      throwErr(\"Graph\", `${ERRORS.INVALID_LINKS} - \"${l.source}\" is not a valid source node id`);\n    }\n\n    if (!data.nodes.find(n => n.id === l.target)) {\n      throwErr(\"Graph\", `${ERRORS.INVALID_LINKS} - \"${l.target}\" is not a valid target node id`);\n    }\n\n    if (l && l.value !== undefined && typeof l.value !== \"number\") {\n      throwErr(\"Graph\", `${ERRORS.INVALID_LINK_VALUE} - found in link with source \"${l.source}\" and target \"${l.target}\"`);\n    }\n  }\n} // list of properties that are of no interest when it comes to nodes and links comparison\n\n\nconst NODE_PROPERTIES_DISCARD_TO_COMPARE = [\"x\", \"y\", \"vx\", \"vy\", \"index\"];\n/**\n * Picks the id.\n * @param {Object} o object to pick from.\n * @returns {Object} new object with id property only.\n * @memberof Graph/helper\n */\n\nfunction _pickId(o) {\n  return pick(o, [\"id\"]);\n}\n/**\n * Picks source and target.\n * @param {Object} o object to pick from.\n * @returns {Object} new object with source and target only.\n * @memberof Graph/helper\n */\n\n\nfunction _pickSourceAndTarget(o) {\n  return pick(o, [\"source\", \"target\"]);\n}\n/**\n * This function checks for graph elements (nodes and links) changes, in two different\n * levels of significance, updated elements (whether some property has changed in some\n * node or link) and new elements (whether some new elements or added/removed from the graph).\n * @param {Object} nextProps - nextProps that graph will receive.\n * @param {Object} currentState - the current state of the graph.\n * @returns {Object.<string, boolean>} returns object containing update check flags:\n * - newGraphElements - flag that indicates whether new graph elements were added.\n * - graphElementsUpdated - flag that indicates whether some graph elements have\n * updated (some property that is not in NODE_PROPERTIES_DISCARD_TO_COMPARE was added to\n * some node or link or was updated).\n * @memberof Graph/helper\n */\n\n\nfunction checkForGraphElementsChanges(nextProps, currentState) {\n  const nextNodes = nextProps.data.nodes.map(n => antiPick(n, NODE_PROPERTIES_DISCARD_TO_COMPARE));\n  const nextLinks = nextProps.data.links;\n  const stateD3Nodes = currentState.d3Nodes.map(n => antiPick(n, NODE_PROPERTIES_DISCARD_TO_COMPARE));\n  const stateD3Links = currentState.d3Links.map(l => ({\n    source: getId(l.source),\n    target: getId(l.target)\n  }));\n  const graphElementsUpdated = !(isDeepEqual(nextNodes, stateD3Nodes) && isDeepEqual(nextLinks, stateD3Links));\n  const newGraphElements = nextNodes.length !== stateD3Nodes.length || nextLinks.length !== stateD3Links.length || !isDeepEqual(nextNodes.map(_pickId), stateD3Nodes.map(_pickId)) || !isDeepEqual(nextLinks.map(_pickSourceAndTarget), stateD3Links.map(_pickSourceAndTarget));\n  return {\n    graphElementsUpdated,\n    newGraphElements\n  };\n}\n/**\n * Logic to check for changes in graph config.\n * @param {Object} nextProps - nextProps that graph will receive.\n * @param {Object} currentState - the current state of the graph.\n * @returns {Object.<string, boolean>} returns object containing update check flags:\n * - configUpdated - global flag that indicates if any property was updated.\n * - d3ConfigUpdated - specific flag that indicates changes in d3 configurations.\n * @memberof Graph/helper\n */\n\n\nfunction checkForGraphConfigChanges(nextProps, currentState) {\n  const newConfig = nextProps.config || {};\n  const configUpdated = newConfig && !isEmptyObject(newConfig) && !isDeepEqual(newConfig, currentState.config);\n  const d3ConfigUpdated = newConfig && newConfig.d3 && !isDeepEqual(newConfig.d3, currentState.config.d3);\n  return {\n    configUpdated,\n    d3ConfigUpdated\n  };\n}\n/**\n * Returns the transformation to apply in order to center the graph on the\n * selected node.\n * @param {Object} d3Node - node to focus the graph view on.\n * @param {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @returns {string|undefined} transform rule to apply.\n * @memberof Graph/helper\n */\n\n\nfunction getCenterAndZoomTransformation(d3Node, config) {\n  if (!d3Node) {\n    return;\n  }\n\n  const {\n    width,\n    height,\n    focusZoom\n  } = config;\n  return `\n        translate(${width / 2}, ${height / 2})\n        scale(${focusZoom})\n        translate(${-d3Node.x}, ${-d3Node.y})\n    `;\n}\n/**\n * This function extracts an id from a link.\n * **Why this function?**\n * According to [d3-force](https://github.com/d3/d3-force#link_links)\n * d3 links might be initialized with \"source\" and \"target\"\n * properties as numbers or strings, but after initialization they\n * are converted to an object. This small utility functions ensures\n * that weather in initialization or further into the lifetime of the graph\n * we always get the id.\n * @param {Object|string|number} sot source or target\n * of the link to extract id.\n * we want to extract an id.\n * @returns {string|number} the id of the link.\n * @memberof Graph/helper\n */\n\n\nfunction getId(sot) {\n  return sot.id !== undefined && sot.id !== null ? sot.id : sot;\n}\n/**\n * Encapsulates common procedures to initialize graph.\n * @param {Object} props - Graph component props, object that holds data, id and config.\n * @param {Object} props.data - Data object holds links (array of **Link**) and nodes (array of **Node**).\n * @param {string} props.id - the graph id.\n * @param {Object} props.config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {Object} state - Graph component current state (same format as returned object on this function).\n * @returns {Object} a fully (re)initialized graph state object.\n * @memberof Graph/helper\n */\n\n\nfunction initializeGraphState({\n  data,\n  id,\n  config,\n  algoData\n}, state) {\n  _validateGraphData(data);\n\n  let graph;\n\n  if (state && state.nodes) {\n    graph = {\n      nodes: data.nodes.map(n => state.nodes[n.id] ? { ...n,\n        ...pick(state.nodes[n.id], NODE_PROPS_WHITELIST)\n      } : { ...n\n      }),\n      links: data.links.map((l, index) => _mergeDataLinkWithD3Link(l, index, state && state.d3Links, config, state))\n    };\n  } else {\n    graph = {\n      nodes: data.nodes.map(n => ({ ...n\n      })),\n      links: data.links.map(l => ({ ...l\n      }))\n    };\n  }\n\n  let newConfig = { ...merge(DEFAULT_CONFIG, config || {})\n  },\n      links = _initializeLinks(graph.links, newConfig),\n      // matrix of graph connections\n  nodes = _tagOrphanNodes(_initializeNodes(graph.nodes), links);\n\n  const {\n    nodes: d3Nodes,\n    links: d3Links\n  } = graph;\n  const formatedId = id.replace(/ /g, \"_\");\n\n  const simulation = _createForceSimulation(newConfig.width, newConfig.height, newConfig.d3 && newConfig.d3.gravity);\n\n  const {\n    minZoom,\n    maxZoom,\n    focusZoom\n  } = newConfig;\n\n  if (focusZoom > maxZoom) {\n    newConfig.focusZoom = maxZoom;\n  } else if (focusZoom < minZoom) {\n    newConfig.focusZoom = minZoom;\n  }\n\n  return {\n    id: formatedId,\n    config: newConfig,\n    links,\n    d3Links,\n    nodes,\n    d3Nodes,\n    highlightedNode: \"\",\n    simulation,\n    newGraphElements: false,\n    configUpdated: false,\n    transform: 1,\n    draggedNode: null\n  };\n}\n/**\n * This function updates the highlighted value for a given node and also updates highlight props.\n * @param {Object.<string, Object>} nodes - an object containing all nodes mapped by their id.\n * @param {Object.<string, Object>} links - an object containing a matrix of connections of the graph.\n * @param {Object} config - an object containing rd3g consumer defined configurations {@link #config config} for the graph.\n * @param {string} id - identifier of node to update.\n * @param {string} value - new highlight value for given node.\n * @returns {Object} returns an object containing the updated nodes\n * and the id of the highlighted node.\n * @memberof Graph/helper\n */\n\n\nfunction updateNodeHighlightedValue(nodes, links, config, id, value = false) {\n  const highlightedNode = value ? id : \"\";\n  const node = { ...nodes[id],\n    highlighted: value\n  };\n  let updatedNodes = { ...nodes,\n    [id]: node\n  }; // when highlightDegree is 0 we want only to highlight selected node\n\n  if (links[id] && config.highlightDegree !== 0) {\n    updatedNodes = Object.keys(links[id]).reduce((acc, linkId) => {\n      const updatedNode = { ...updatedNodes[linkId],\n        highlighted: value\n      };\n      acc[linkId] = updatedNode;\n      return acc;\n    }, updatedNodes);\n  }\n\n  return {\n    nodes: updatedNodes,\n    highlightedNode\n  };\n}\n\nexport { checkForGraphConfigChanges, checkForGraphElementsChanges, getCenterAndZoomTransformation, getId, initializeGraphState, updateNodeHighlightedValue };","map":{"version":3,"sources":["/Users/baljeetsingh/Desktop/software/s2020-djma/algo_interact/frontend/src/components/Visualizer/LinkedList/Graph/graph/graph.helper.js"],"names":["forceX","d3ForceX","forceY","d3ForceY","forceSimulation","d3ForceSimulation","forceManyBody","d3ForceManyBody","CONST","DEFAULT_CONFIG","ERRORS","isDeepEqual","isEmptyObject","merge","pick","antiPick","throwErr","throwWarning","computeNodeDegree","NODE_PROPS_WHITELIST","LINK_PROPS_WHITELIST","_createForceSimulation","width","height","gravity","frx","strength","FORCE_X","fry","FORCE_Y","forceStrength","force","_initializeLinks","graphLinks","config","reduce","links","l","source","getId","target","value","collapsible","isHidden","directed","_initializeNodes","graphNodes","nodes","n","length","i","node","highlighted","Object","prototype","hasOwnProperty","call","x","y","id","toString","_mergeDataLinkWithD3Link","link","index","d3Links","state","tmp","find","d3Link","customProps","toggledDirected","refinedD3Link","_tagOrphanNodes","linksMatrix","keys","acc","nodeId","inDegree","outDegree","taggedNode","_orphan","_validateGraphData","data","INSUFFICIENT_DATA","INSUFFICIENT_LINKS","INVALID_LINKS","undefined","INVALID_LINK_VALUE","NODE_PROPERTIES_DISCARD_TO_COMPARE","_pickId","o","_pickSourceAndTarget","checkForGraphElementsChanges","nextProps","currentState","nextNodes","map","nextLinks","stateD3Nodes","d3Nodes","stateD3Links","graphElementsUpdated","newGraphElements","checkForGraphConfigChanges","newConfig","configUpdated","d3ConfigUpdated","d3","getCenterAndZoomTransformation","d3Node","focusZoom","sot","initializeGraphState","algoData","graph","formatedId","replace","simulation","minZoom","maxZoom","highlightedNode","transform","draggedNode","updateNodeHighlightedValue","updatedNodes","highlightDegree","linkId","updatedNode"],"mappings":"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","sourcesContent":["/**\n * @module Graph/helper\n * @description\n * Offers a series of methods that isolate logic of Graph component and also from Graph rendering methods.\n */\n/**\n * @typedef {Object} Link\n * @property {string} source - the node id of the source in the link.\n * @property {string} target - the node id of the target in the link.\n * @memberof Graph/helper\n */\n/**\n * @typedef {Object} Node\n * @property {string} id - the id of the node.\n * @property {string} [color=] - color of the node (optional).\n * @property {string} [fontColor=] - node text label font color (optional).\n * @property {string} [size=] - size of the node (optional).\n * @property {string} [symbolType=] - symbol type of the node (optional).\n * @property {string} [svg=] - custom svg for node (optional).\n * @memberof Graph/helper\n */\nimport {\n  forceX as d3ForceX,\n  forceY as d3ForceY,\n  forceSimulation as d3ForceSimulation,\n  forceManyBody as d3ForceManyBody\n} from \"d3-force\";\n\nimport CONST from \"./graph.const\";\nimport DEFAULT_CONFIG from \"./graph.config\";\nimport ERRORS from \"../err\";\n\nimport {\n  isDeepEqual,\n  isEmptyObject,\n  merge,\n  pick,\n  antiPick,\n  throwErr,\n  throwWarning\n} from \"../utils\";\nimport { computeNodeDegree } from \"./collapse.helper\";\n\nconst NODE_PROPS_WHITELIST = [\n  \"id\",\n  \"highlighted\",\n  \"x\",\n  \"y\",\n  \"index\",\n  \"vy\",\n  \"vx\"\n];\nconst LINK_PROPS_WHITELIST = [\"index\", \"source\", \"target\", \"isHidden\"];\n\n/**\n * Create d3 forceSimulation to be applied on the graph.<br/>\n * {@link https://github.com/d3/d3-force#forceSimulation|d3-force#forceSimulation}<br/>\n * {@link https://github.com/d3/d3-force#simulation_force|d3-force#simulation_force}<br/>\n * Wtf is a force? {@link https://github.com/d3/d3-force#forces| here}\n * @param  {number} width - the width of the container area of the graph.\n * @param  {number} height - the height of the container area of the graph.\n * @param  {number} gravity - the force strength applied to the graph.\n * @returns {Object} returns the simulation instance to be consumed.\n * @memberof Graph/helper\n */\nfunction _createForceSimulation(width, height, gravity) {\n  const frx = d3ForceX(width / 2).strength(CONST.FORCE_X);\n  const fry = d3ForceY(height / 2).strength(CONST.FORCE_Y);\n  const forceStrength = gravity;\n\n  return d3ForceSimulation()\n    .force(\"charge\", d3ForceManyBody().strength(forceStrength))\n    .force(\"x\", frx)\n    .force(\"y\", fry);\n}\n\n/**\n * Receives a matrix of the graph with the links source and target as concrete node instances and it transforms it\n * in a lightweight matrix containing only links with source and target being strings representative of some node id\n * and the respective link value (if non existent will default to 1).\n * @param  {Array.<Link>} graphLinks - an array of all graph links.\n * @param  {Object} config - the graph config.\n * @returns {Object.<string, Object>} an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @memberof Graph/helper\n */\nfunction _initializeLinks(graphLinks, config) {\n  return graphLinks.reduce((links, l) => {\n    const source = getId(l.source);\n    const target = getId(l.target);\n\n    if (!links[source]) {\n      links[source] = {};\n    }\n\n    if (!links[target]) {\n      links[target] = {};\n    }\n\n    const value = config.collapsible && l.isHidden ? 0 : l.value || 1;\n\n    links[source][target] = value;\n\n    if (!config.directed) {\n      links[target][source] = value;\n    }\n\n    return links;\n  }, {});\n}\n\n/**\n * Method that initialize graph nodes provided by rd3g consumer and adds additional default mandatory properties\n * that are optional for the user. Also it generates an index mapping, this maps nodes ids the their index in the array\n * of nodes. This is needed because d3 callbacks such as node click and link click return the index of the node.\n * @param  {Array.<Node>} graphNodes - the array of nodes provided by the rd3g consumer.\n * @returns {Object.<string, Object>} returns the nodes ready to be used within rd3g with additional properties such as x, y\n * and highlighted values.\n * @memberof Graph/helper\n */\nfunction _initializeNodes(graphNodes) {\n  let nodes = {};\n  const n = graphNodes.length;\n\n  for (let i = 0; i < n; i++) {\n    const node = graphNodes[i];\n\n    node.highlighted = false;\n\n    if (!Object.prototype.hasOwnProperty.call(node, \"x\")) {\n      node.x = 0;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(node, \"y\")) {\n      node.y = 0;\n    }\n\n    nodes[node.id.toString()] = node;\n  }\n\n  return nodes;\n}\n\n/**\n * Maps an input link (with format `{ source: 'sourceId', target: 'targetId' }`) to a d3Link\n * (with format `{ source: { id: 'sourceId' }, target: { id: 'targetId' } }`). If d3Link with\n * given index exists already that same d3Link is returned.\n * @param {Object} link - input link.\n * @param {number} index - index of the input link.\n * @param {Array.<Object>} d3Links - all d3Links.\n * @param  {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {Object} state - Graph component current state (same format as returned object on this function).\n * @returns {Object} a d3Link.\n * @memberof Graph/helper\n */\nfunction _mergeDataLinkWithD3Link(\n  link,\n  index,\n  d3Links = [],\n  config,\n  state = {}\n) {\n  // find the matching link if it exists\n  const tmp = d3Links.find(\n    l => l.source.id === link.source && l.target.id === link.target\n  );\n  const d3Link = tmp && pick(tmp, LINK_PROPS_WHITELIST);\n  const customProps = antiPick(link, [\"source\", \"target\"]);\n\n  if (d3Link) {\n    const toggledDirected =\n      state.config &&\n      Object.prototype.hasOwnProperty.call(state.config, \"directed\") &&\n      config.directed !== state.config.directed;\n    const refinedD3Link = {\n      index,\n      ...d3Link,\n      ...customProps\n    };\n\n    // every time we toggle directed config all links should be visible again\n    if (toggledDirected) {\n      return { ...refinedD3Link, isHidden: false };\n    }\n\n    // every time we disable collapsible (collapsible is false) all links should be visible again\n    return config.collapsible\n      ? refinedD3Link\n      : { ...refinedD3Link, isHidden: false };\n  }\n\n  const highlighted = false;\n  const source = {\n    id: link.source,\n    highlighted\n  };\n  const target = {\n    id: link.target,\n    highlighted\n  };\n\n  return {\n    index,\n    source,\n    target,\n    ...customProps\n  };\n}\n\n/**\n * Tags orphan nodes with a `_orphan` flag.\n * @param {Object.<string, Object>} nodes - nodes mapped by their id.\n * @param {Object.<string, Object>} linksMatrix - an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @returns {Object.<string, Object>} same input nodes structure with tagged orphans nodes where applicable.\n * @memberof Graph/helper\n */\nfunction _tagOrphanNodes(nodes, linksMatrix) {\n  return Object.keys(nodes).reduce((acc, nodeId) => {\n    const { inDegree, outDegree } = computeNodeDegree(nodeId, linksMatrix);\n    const node = nodes[nodeId];\n    const taggedNode =\n      inDegree === 0 && outDegree === 0 ? { ...node, _orphan: true } : node;\n\n    acc[nodeId] = taggedNode;\n\n    return acc;\n  }, {});\n}\n\n/**\n * Some integrity validations on links and nodes structure. If some validation fails the function will\n * throw an error.\n * @param  {Object} data - Same as {@link #initializeGraphState|data in initializeGraphState}.\n * @throws can throw the following error or warning msg:\n * INSUFFICIENT_DATA - msg if no nodes are provided\n * INVALID_LINKS - if links point to nonexistent nodes\n * INSUFFICIENT_LINKS - if no links are provided\n * @returns {undefined}\n * @memberof Graph/helper\n */\nfunction _validateGraphData(data) {\n  if (!data.nodes || !data.nodes.length) {\n    throwErr(\"Graph\", ERRORS.INSUFFICIENT_DATA);\n  }\n\n  if (!data.links || !data.links.length) {\n    throwWarning(\"Graph\", ERRORS.INSUFFICIENT_LINKS);\n    data.links = [];\n  }\n\n  const n = data.links.length;\n\n  for (let i = 0; i < n; i++) {\n    const l = data.links[i];\n\n    if (!data.nodes.find(n => n.id === l.source)) {\n      throwErr(\n        \"Graph\",\n        `${ERRORS.INVALID_LINKS} - \"${l.source}\" is not a valid source node id`\n      );\n    }\n\n    if (!data.nodes.find(n => n.id === l.target)) {\n      throwErr(\n        \"Graph\",\n        `${ERRORS.INVALID_LINKS} - \"${l.target}\" is not a valid target node id`\n      );\n    }\n\n    if (l && l.value !== undefined && typeof l.value !== \"number\") {\n      throwErr(\n        \"Graph\",\n        `${ERRORS.INVALID_LINK_VALUE} - found in link with source \"${l.source}\" and target \"${l.target}\"`\n      );\n    }\n  }\n}\n\n// list of properties that are of no interest when it comes to nodes and links comparison\nconst NODE_PROPERTIES_DISCARD_TO_COMPARE = [\"x\", \"y\", \"vx\", \"vy\", \"index\"];\n\n/**\n * Picks the id.\n * @param {Object} o object to pick from.\n * @returns {Object} new object with id property only.\n * @memberof Graph/helper\n */\nfunction _pickId(o) {\n  return pick(o, [\"id\"]);\n}\n\n/**\n * Picks source and target.\n * @param {Object} o object to pick from.\n * @returns {Object} new object with source and target only.\n * @memberof Graph/helper\n */\nfunction _pickSourceAndTarget(o) {\n  return pick(o, [\"source\", \"target\"]);\n}\n\n/**\n * This function checks for graph elements (nodes and links) changes, in two different\n * levels of significance, updated elements (whether some property has changed in some\n * node or link) and new elements (whether some new elements or added/removed from the graph).\n * @param {Object} nextProps - nextProps that graph will receive.\n * @param {Object} currentState - the current state of the graph.\n * @returns {Object.<string, boolean>} returns object containing update check flags:\n * - newGraphElements - flag that indicates whether new graph elements were added.\n * - graphElementsUpdated - flag that indicates whether some graph elements have\n * updated (some property that is not in NODE_PROPERTIES_DISCARD_TO_COMPARE was added to\n * some node or link or was updated).\n * @memberof Graph/helper\n */\n\nfunction checkForGraphElementsChanges(nextProps, currentState) {\n  const nextNodes = nextProps.data.nodes.map(n =>\n    antiPick(n, NODE_PROPERTIES_DISCARD_TO_COMPARE)\n  );\n  const nextLinks = nextProps.data.links;\n  const stateD3Nodes = currentState.d3Nodes.map(n =>\n    antiPick(n, NODE_PROPERTIES_DISCARD_TO_COMPARE)\n  );\n  const stateD3Links = currentState.d3Links.map(l => ({\n    source: getId(l.source),\n    target: getId(l.target)\n  }));\n  const graphElementsUpdated = !(\n    isDeepEqual(nextNodes, stateD3Nodes) && isDeepEqual(nextLinks, stateD3Links)\n  );\n  const newGraphElements =\n    nextNodes.length !== stateD3Nodes.length ||\n    nextLinks.length !== stateD3Links.length ||\n    !isDeepEqual(nextNodes.map(_pickId), stateD3Nodes.map(_pickId)) ||\n    !isDeepEqual(\n      nextLinks.map(_pickSourceAndTarget),\n      stateD3Links.map(_pickSourceAndTarget)\n    );\n\n  return { graphElementsUpdated, newGraphElements };\n}\n\n/**\n * Logic to check for changes in graph config.\n * @param {Object} nextProps - nextProps that graph will receive.\n * @param {Object} currentState - the current state of the graph.\n * @returns {Object.<string, boolean>} returns object containing update check flags:\n * - configUpdated - global flag that indicates if any property was updated.\n * - d3ConfigUpdated - specific flag that indicates changes in d3 configurations.\n * @memberof Graph/helper\n */\nfunction checkForGraphConfigChanges(nextProps, currentState) {\n  const newConfig = nextProps.config || {};\n  const configUpdated =\n    newConfig &&\n    !isEmptyObject(newConfig) &&\n    !isDeepEqual(newConfig, currentState.config);\n  const d3ConfigUpdated =\n    newConfig &&\n    newConfig.d3 &&\n    !isDeepEqual(newConfig.d3, currentState.config.d3);\n\n  return { configUpdated, d3ConfigUpdated };\n}\n\n/**\n * Returns the transformation to apply in order to center the graph on the\n * selected node.\n * @param {Object} d3Node - node to focus the graph view on.\n * @param {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @returns {string|undefined} transform rule to apply.\n * @memberof Graph/helper\n */\nfunction getCenterAndZoomTransformation(d3Node, config) {\n  if (!d3Node) {\n    return;\n  }\n\n  const { width, height, focusZoom } = config;\n\n  return `\n        translate(${width / 2}, ${height / 2})\n        scale(${focusZoom})\n        translate(${-d3Node.x}, ${-d3Node.y})\n    `;\n}\n\n/**\n * This function extracts an id from a link.\n * **Why this function?**\n * According to [d3-force](https://github.com/d3/d3-force#link_links)\n * d3 links might be initialized with \"source\" and \"target\"\n * properties as numbers or strings, but after initialization they\n * are converted to an object. This small utility functions ensures\n * that weather in initialization or further into the lifetime of the graph\n * we always get the id.\n * @param {Object|string|number} sot source or target\n * of the link to extract id.\n * we want to extract an id.\n * @returns {string|number} the id of the link.\n * @memberof Graph/helper\n */\nfunction getId(sot) {\n  return sot.id !== undefined && sot.id !== null ? sot.id : sot;\n}\n\n/**\n * Encapsulates common procedures to initialize graph.\n * @param {Object} props - Graph component props, object that holds data, id and config.\n * @param {Object} props.data - Data object holds links (array of **Link**) and nodes (array of **Node**).\n * @param {string} props.id - the graph id.\n * @param {Object} props.config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {Object} state - Graph component current state (same format as returned object on this function).\n * @returns {Object} a fully (re)initialized graph state object.\n * @memberof Graph/helper\n */\nfunction initializeGraphState({ data, id, config, algoData }, state) {\n  _validateGraphData(data);\n\n  let graph;\n\n  if (state && state.nodes) {\n    graph = {\n      nodes: data.nodes.map(n =>\n        state.nodes[n.id]\n          ? { ...n, ...pick(state.nodes[n.id], NODE_PROPS_WHITELIST) }\n          : { ...n }\n      ),\n      links: data.links.map((l, index) =>\n        _mergeDataLinkWithD3Link(\n          l,\n          index,\n          state && state.d3Links,\n          config,\n          state\n        )\n      )\n    };\n  } else {\n    graph = {\n      nodes: data.nodes.map(n => ({ ...n })),\n      links: data.links.map(l => ({ ...l }))\n    };\n  }\n\n  let newConfig = { ...merge(DEFAULT_CONFIG, config || {}) },\n    links = _initializeLinks(graph.links, newConfig), // matrix of graph connections\n    nodes = _tagOrphanNodes(_initializeNodes(graph.nodes), links);\n  const { nodes: d3Nodes, links: d3Links } = graph;\n  const formatedId = id.replace(/ /g, \"_\");\n  const simulation = _createForceSimulation(\n    newConfig.width,\n    newConfig.height,\n    newConfig.d3 && newConfig.d3.gravity\n  );\n  const { minZoom, maxZoom, focusZoom } = newConfig;\n\n  if (focusZoom > maxZoom) {\n    newConfig.focusZoom = maxZoom;\n  } else if (focusZoom < minZoom) {\n    newConfig.focusZoom = minZoom;\n  }\n\n  return {\n    id: formatedId,\n    config: newConfig,\n    links,\n    d3Links,\n    nodes,\n    d3Nodes,\n    highlightedNode: \"\",\n    simulation,\n    newGraphElements: false,\n    configUpdated: false,\n    transform: 1,\n    draggedNode: null\n  };\n}\n\n/**\n * This function updates the highlighted value for a given node and also updates highlight props.\n * @param {Object.<string, Object>} nodes - an object containing all nodes mapped by their id.\n * @param {Object.<string, Object>} links - an object containing a matrix of connections of the graph.\n * @param {Object} config - an object containing rd3g consumer defined configurations {@link #config config} for the graph.\n * @param {string} id - identifier of node to update.\n * @param {string} value - new highlight value for given node.\n * @returns {Object} returns an object containing the updated nodes\n * and the id of the highlighted node.\n * @memberof Graph/helper\n */\nfunction updateNodeHighlightedValue(nodes, links, config, id, value = false) {\n  const highlightedNode = value ? id : \"\";\n  const node = { ...nodes[id], highlighted: value };\n\n  let updatedNodes = { ...nodes, [id]: node };\n\n  // when highlightDegree is 0 we want only to highlight selected node\n  if (links[id] && config.highlightDegree !== 0) {\n    updatedNodes = Object.keys(links[id]).reduce((acc, linkId) => {\n      const updatedNode = { ...updatedNodes[linkId], highlighted: value };\n\n      acc[linkId] = updatedNode;\n\n      return acc;\n    }, updatedNodes);\n  }\n\n  return {\n    nodes: updatedNodes,\n    highlightedNode\n  };\n}\n\nexport {\n  checkForGraphConfigChanges,\n  checkForGraphElementsChanges,\n  getCenterAndZoomTransformation,\n  getId,\n  initializeGraphState,\n  updateNodeHighlightedValue\n};\n"]},"metadata":{},"sourceType":"module"}